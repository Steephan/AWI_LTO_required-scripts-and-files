###############################################################################
#
#   LEVEL1 filter/flag functions
#
#   #   written by: stephan.lange@awi.de
#
#   last check: 2020-05-20
#   checked by: christian.lehr@awi.de
#
#############################################################################
#   last modified:
#
#   2020-05-20 CL update of comments
#                 replaced "tmp[(tmp > 10) & (new.data == flag)] <- flag" in update.flags()) function
#
#
##
####
####
####
####
####
####
####
###
##
#


## ==============================================================================
##
## Additional functions needed
##

########################

############
# the update.filter() tool reads the flags from the provided filter table
############
update.filter <- function(dats, db.filter.list, flag = 6) {
  db.filter.list <- db.filter.list[db.filter.list$flag == as.character(flag), ]
  if (nrow(db.filter.list) > 0) {
    for (row.i in 1:nrow(db.filter.list)) {

      dats[ which( (dats$UTC >= db.filter.list$from[row.i]) &
                     (dats$UTC <= db.filter.list$to[row.i]) &
                     (dats[which(colnames(dats) == db.filter.list$variable[row.i]) + 1] == 0 |
                      dats[which(colnames(dats) == db.filter.list$variable[row.i]) + 1] >= flag) &
                     (dats[, (which(colnames(dats) == db.filter.list$variable[row.i]))] >= db.filter.list$min[row.i]) &     # Minimum Value
                     (dats[, (which(colnames(dats) == db.filter.list$variable[row.i]))] <= db.filter.list$max[row.i])    # Maximum Value
      ), which(colnames(dats) == db.filter$variable[row.i]) + 1 ] <- flag
    }
  }
  return(dats)
}


############
# the check.double.entry() tool removes double entries in the raw tables
############
check.double.entry <- function(data) {
  if (("TRUE" %in% duplicated(data)) == TRUE) {
    # check for fully double entries
    doouble <- duplicated(data)
    # remove double entries
    data <- unique(data)
    return(data)
  } else if (("TRUE" %in% duplicated(data[, 1])) == TRUE) {
    # check for multiple different data records for same timestamp
    doouble <- duplicated(data[, 1])
    dd <- which(data[, 1] %in% data[which(doouble == "TRUE"), 1])
    # remove double entries
    data <- data[-dd, ]
    return(data)
  } else {
    return(data)
  }
}

############
# the log.peaks() tool updates the log-file with time and choosen option of spike-detection
# spike-detection is a slow computing function ...
# ==> for faster performance run the script without spike-detection
# ==> for best quality only with spike-detection
############
log.peaks <- function(dstation, dyear, d.mit.peak.detection) {
  suppressWarnings({
    p.log <- read.table(paste0(p.1$w[p.1$n == "log.p"], "peak.log"), sep = ",", dec = ".", header = T)
    p.log$date <- as.character(p.log$date)
    p.log$station <- as.character(p.log$station)
    if (nrow(p.log[(p.log$station == as.character(dstation) & p.log$year == dyear), ]) == 0) {
      pos <- length(p.log[, 1]) + 1
      p.log <- rbind(p.log, "pos" = c(format(Sys.time(), '%Y-%m-%d %H:%M'), dstation, dyear, d.mit.peak.detection))
    } else if (nrow(p.log[(p.log$station == as.character(dstation) & p.log$year == dyear), ]) != 0) {
      p.log[(p.log$station == dstation & p.log$year == dyear), ] <- c(format(Sys.time(), '%Y-%m-%d %H:%M'), dstation, dyear, d.mit.peak.detection)
    }
    p.log <- p.log[order(p.log[, 2], -as.numeric(p.log[, 3])), ]
    cat(c("#\n# log:", format(Sys.time(), '%Y-%m-%d %H:%M'), dstation, dyear, d.mit.peak.detection, "\n"))
    write.table(p.log, paste0(p.1$w[p.1$n == "log.p"], "peak.log"), quote = F, dec = ".", sep = ",", row.names = F)
  })
}



############
# the get.100flag.columns() tool inserts after each column a new flag-column for the flagging routines
# with default value 100 for unflagged data
# after all flagging routines were applied the remaining values with flag 100 are replaced with flag 0 ==> good data
############
get.100flag.columns <- function(lv0.data) {
  db.lvl1 <- lv0.data
  colz <- dim(db.lvl1)[2] - 1

  # create new flag_columns with default flag 100 and named "flag_sensor" for each sensor
  for (i in 2:length(colnames(db.lvl1))) {
    db.lvl1$new <- 100
    colnames(db.lvl1)[ length(db.lvl1) ] <- paste0(colnames(db.lvl1)[i], "_fl")
  }
  # replace dots '.' (generated by colnames) with '()'
  colnames(db.lvl1) <- gsub(x = colnames(db.lvl1), pattern = "\\.", replacement = ")")
  for (i in 1:colz) {
    colnames(db.lvl1) <- gsub(x = colnames(db.lvl1), pattern = paste0(")", i), replacement = paste0("(", i) )
  }
  # reorder dataframe with flag column just after each sensor
  if (colz > 1) {
    db.lvl1 <- db.lvl1[, c(1, c(t(matrix(nrow = colz, ncol = 2, c(2:colz, (colz + 1):(2 * colz + 1)))[])))]
  }
  return(db.lvl1)
}



############
# ==> the update.flags tool() replaces only flag 100 (==> the remaining flag 100s become flag 0s at the end of the flagging procedure)
# In the default workflow the function is called following the increasing sequence of flag numbers from 1 to 8
# ==> If applied in this way, higher ranked flag numbers (lower numeric values) are prioritized in case several flag numbers are assigned to a data value
############
update.flags <- function(old.data, new.data, fl_vector, flag) {
  # new flags are stored temporally in a separate object
  # old flags
  tmp <- old.data[, fl_vector]
  # new flags
  new.data <- new.data[, fl_vector]
  # update flag if:
  # i) yield flag == 100 on the old version of the data set
  # ii) AND are flagged with the new flag
  tmp[(tmp == 100) & (new.data == flag)] <- flag
  old.data[, fl_vector] <- tmp
  return(old.data)
}



